#ifndef PARSER_HPP
#define PARSER_HPP

#include "gameobjects.hpp"

// Namespace to keep `command_set`, `unique_commands`, and `predicate_set` out of the global scope
namespace parserspace
{
    std::set<std::string> command_set = {"attack", "drink", "examine", "get", 
    "go", "grab", "look", "read", "take", "talk", "use"};
    std::set<std::string> unique_commands = {"credits", "exit", "help", 
    "inventory", "leave", "location"};
    std::set<std::string> predicate_set = {"a", "an", "at", "the", "to"};
};

/// @brief Splits a string upon reaching whitespace & repeats until there is no more whitespace
/// @param str The input string
/// @return A vector consisting of all the substrings generated by the function
std::vector<std::string> string_splitter(std::string str)
{
    std::vector<std::string> return_vec;
    std::size_t prev_index = 0;
    std::size_t cur_index = 1;

    if (str.size() <= 1)
    {
        return return_vec;
    }
 
    while (cur_index <= str.size())
    {
        cur_index = str.find(" ", prev_index);
        if (cur_index != std::string::npos)
        {
            return_vec.insert(return_vec.end(), str.substr(prev_index, cur_index - prev_index));
            prev_index = cur_index + 1;
        }
        else if (cur_index == std::string::npos && !return_vec.empty())
        {
            return_vec.insert(return_vec.end(), str.substr(prev_index, str.size()));
            break;
        }
        else
        {
            return_vec.insert(return_vec.end(), str);
            break;
        }
    }

    return return_vec;
}

/// \brief Parses input for a valid combination of an action and `game_object`; 
/// supports parsing statements with predicates & obj. synonyms
/// @param input A string containing the user input from the terminal, provided & set all lowercase by the UI
/// @return An std::pair of a string & a wrapped reference to a `game_object` within `main_objects`
/// \note If an action is invalid, the return string will be empty; similarly, if a unique command 
/// is used or a `game_object` cannot be found, the wrapped reference return will link to `empty_object`
std::pair<std::string, std::reference_wrapper<game_object>> game_input_parser(std::string input)
{
    std::string return_str;
    std::reference_wrapper<game_object> return_obj = specificvars::empty_object;

    if (input.empty())
    {
       return {return_str, return_obj};
    }

    std::vector<std::string> input_vec = string_splitter(input);
    std::size_t input_vec_size = input_vec.size();

    if (input_vec_size == 0)
    {
        return {return_str, return_obj};
    }
    else if (input_vec_size == 1 && parserspace::unique_commands.contains(input_vec.at(0)))
    {
        return_str = input_vec.at(0);
    }
    else if (parserspace::command_set.contains(input_vec.at(0)))
    {
        return_str = input_vec.at(0);
        
        int i = 1;
        while (i < input_vec_size)
        {
            if (!parserspace::predicate_set.contains(input_vec.at(i)))
            {
                break;
            }
            i++;
        }

        std::string combined_str;
        for (i; i < input_vec_size; i++)
        {
            if (i == input_vec_size - 1)
            {
                combined_str += input_vec.at(i);
            }
            else
            {
                combined_str += input_vec.at(i) + " ";
            }
        }

        if (!combined_str.empty()) 
        {
            return_obj = find_object(combined_str);
        }
    }

    return {return_str, return_obj};
}

#endif